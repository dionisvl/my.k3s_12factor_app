@startuml k3s Nginx Hello World Sequence (Enhanced)
!theme plain

actor Developer as D
participant "kubectl" as K
participant "k3s Cluster" as K3S
participant "API Server" as API
participant "Controller Manager" as CM
participant "Scheduler" as S
participant "Kubelet" as KL
participant "nginx Pod 1" as NP1
participant "nginx Pod 2" as NP2
participant "nginx-hello-service" as SVC

== Build & Load Image ==
D -> D: docker build -t nginx_hello-nginx:4190fc7 .\n(with config.domains support + curl for healthcheck)
D -> K3S: k3d image import nginx_hello-nginx:4190fc7 -c hello-world-cluster

== Deployment Creation (Multiple Options) ==
alt Manual k8s manifests
    D -> K: DOMAIN_1="localhost" DOMAIN_2="site-r1.local" envsubst < k3s/configmap.yaml | kubectl apply -f -
    D -> K: kubectl apply -f k3s/k8s-deployment.yaml
else Helm deployment
    D -> K: helm upgrade --install nginx-hello helm/nginx-hello/\n--set config.domains='{localhost,site-r1.local,site-r2.local}'\n --set image.tag=4190fc7 --set image.pullPolicy=Never
end
K -> API: Create ConfigMap, Deployment & Service
API -> CM: Watch Deployment (replicas: 2)
CM -> API: Create ReplicaSet
API -> S: Schedule 2 Pods
S -> API: Assign Pods to Node
API -> KL: Create Pod nginx-hello-1
API -> KL: Create Pod nginx-hello-2

== Pod Initialization ==
KL -> NP1: Start nginx container (non-root user:101)
KL -> NP2: Start nginx container (non-root user:101)
NP1 -> NP1: Read config.domains from ConfigMap\nBuild NGINX_SERVER_NAME in entrypoint.sh\nenvsubst nginx.conf.template -> /tmp/nginx.conf\nServe src/html/index.html & /health endpoint\nLogs to stdout/stderr (12-factor compliance)
NP2 -> NP2: Read config.domains from ConfigMap\nBuild NGINX_SERVER_NAME in entrypoint.sh\nenvsubst nginx.conf.template -> /tmp/nginx.conf\nServe src/html/index.html & /health endpoint\nLogs to stdout/stderr (12-factor compliance)

== Health Checks ==
KL -> NP1: Readiness Probe GET /health
NP1 -> KL: HTTP 200 OK
KL -> NP2: Readiness Probe GET /health  
NP2 -> KL: HTTP 200 OK
KL -> API: Pods Ready

== Service Creation ==
API -> KP: Create Service nginx-hello-service
KP -> KP: Setup iptables rules\nfor NodePort 30080\nLoad balance between pods

== Automated Testing (make k3d-test-isolated) ==
D -> K: kubectl exec POD_NAME -- curl -f http://localhost:8080/
K -> NP1: Execute curl inside pod (direct internal access)
NP1 -> NP1: Serve static HTML\n/usr/share/nginx/html/index.html\n(ðŸŽ‰ Hello World with CSS)
NP1 -> K: HTTP 200 + Beautiful HTML content
K -> D: âœ… Main page OK

D -> K: kubectl exec POD_NAME -- curl -f http://localhost:8080/health
K -> NP2: Execute curl inside pod (direct internal access)
NP2 -> NP2: Process health check\nreturn 200 'OK'
NP2 -> K: HTTP 200 OK
K -> D: âœ… Health check OK

note over D, NP2: Automated testing avoids port-forward hangs\nand tests application directly in cluster

== Continuous Health Monitoring ==
loop Every 10 seconds (Liveness) / 5 seconds (Readiness)
    KL -> NP1: Liveness Probe GET /health
    NP1 -> KL: HTTP 200 OK
    KL -> NP2: Liveness Probe GET /health
    NP2 -> KL: HTTP 200 OK
    note over KL, NP2: Resource limits: 64Mi-128Mi RAM\n250m-500m CPU
end

== Configuration Update (Production) ==
alt Via Helm values
    D -> K: helm upgrade nginx-hello helm/nginx-hello/\n--values helm/nginx-hello/values-prod.yaml\n--set config.domains='{example.com,www.example.com}'
else Via kubectl
    D -> K: DOMAIN_1="example.com" DOMAIN_2="www.example.com" envsubst < k3s/configmap-prod.yaml | kubectl apply -f -
    D -> K: kubectl rollout restart deployment nginx-hello
end
K -> API: Update ConfigMap with new domains
K -> API: Restart deployment (if needed)
API -> KL: Rolling restart pods
note over D, KL: New pods pick up production domains\nfrom consolidated config.domains

== Scaling Test ==
D -> K: kubectl scale deployment nginx-hello --replicas=1
K -> API: Update replicas
API -> KL: Terminate Pod nginx-hello-2
KL -> NP2: Graceful shutdown
D -> K: kubectl scale deployment nginx-hello --replicas=2
K -> API: Update replicas
API -> KL: Create new Pod nginx-hello-3
note over D, KL: Rolling update ensures zero downtime

== Ingress Setup (Traefik - k3s built-in) ==
note over D, K3S: k3s includes Traefik ingress controller by default
D -> K: kubectl apply -f k3s/ingress-dev.yaml\n(ingressClassName: traefik)
K -> API: Create Ingress resource
API -> K3S: Configure Traefik routing rules
note over API, K3S: Ingress ready but testing uses direct pod access\nfor reliability and speed

== Custom Ports (Avoid Conflicts) ==
note over D, K3S: Multiple projects can run simultaneously
D -> D: K3D_API_PORT=6444 K3D_LB_PORT=8081\nmake k3d-cluster-isolated
D -> K3S: k3d cluster create hello-world-cluster\n--api-port 127.0.0.1:6444\n--port 8081:80@loadbalancer
note over D, K3S: Configurable ports prevent conflicts\nwith other k3d clusters

@enduml